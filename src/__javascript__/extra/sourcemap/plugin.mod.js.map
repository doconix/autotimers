{
	"version": 3,
	"file": "src/__javascript__/plugin.mod.js",
	"sources": [
		"src/plugin.py"
	],
	"sourcesContent": [
		"#\n# Publishing reminder:\n#\n# Change the version number in all the files.\n# git commit -am 'message'\n# git push origin master\n# git tag 2.0.1\n# git push origin --tags\n#\n#\n# Author: Conan C. Albrecht <doconix@gmail.com>\n# Version: 2.0.1\n# License: MIT\n#\n# tl;dr:\n#\n#     Wait four seconds, then run one time:\n#         $('#somediv').timers().Timer({ \n#             'millis': 4000 \n#         }).do((tmr) => {\n#             console.log('one time joe!')\n#         })\n#     \n#     Run immediately, then repeatedly run exactly four seconds after the *end* of the previous run:\n#         $('#somediv').timers().SleepAfterTimer({ 'millis': 4000 }).do((tmr) => {\n#             console.log('right now, then again and again!')\n#         })\n#     \n#     Wait four seconds, then repeatedly run exactly four seconds after the *start* of the\n#     previous run. Stop after five runs:\n#         $('#somediv').timers().IntervalTimer({ \n#             'millis': 4000, \n#             'max_runs': 5 \n#         }).do((tmr) => {\n#             console.log('wait first, then again and again!')\n#         })\n#     \n#     Check every fours seconds for boolean to be true, then stop checking:\n#         $('#somediv').timers().SleepAfterTimer({ \n#             'millis': 4000 \n#         }).do((tmr) => {\n#             if (somebool) {\n#                 tmr.cancel()\n#             }\n#         })\n#     \n# Description:\n#     A jQuery plugin that provides three types of timers (with additional variations):\n#\n#     Regular Timer: Runs the do() function(s) one time after the given millis.\n#     \n#         For example, suppose millis is 120 (2 seconds):\n#           * After 2 seconds, do() is called.  The timer is finished at that point.\n#\n#     Sleep and SleepAfter Timers: Repeating timer that ensures an exact time between runs.\n#     \n#         This is very similar to the normal window.setInterval(), but it ensures\n#         an exact amount of time occurs between calls to do().  In other words,\n#         a \"sleep\" time between calls is enforced; the timer is restarted only when\n#         do() returns.\n#     \n#         For example, suppose millis is 120 (2 seconds):\n#           * If do() takes 1 seconds, do() will be called again 2 seconds after\n#             the end of the previous run (3 seconds after the previous start)\n#           * If do() takes 2 seconds, do() will be called again 2 seconds after\n#             the end of the previous run (4 seconds after the previous start)\n#           * If do() takes 3 seconds, do() will be called again 2 seconds after\n#             the end of the previous run (5 seconds after the previous start)\n#     \n#     Interval and IntervalAfter Timers:\n#     \n#         Sets a repeating timer that starts at a speific interval,\n#         This is very similar to the normal window.setInterval(), but this version\n#         does not allow do() to run concurrently with another run of itself.\n#     \n#         For example, suppose millis is 120 (2 seconds):\n#           * If do() takes 1 seconds, do() will be called again 1 second after\n#             the end of the previous run.\n#           * If do() takes 2 seconds, do() will be called again immediately after\n#             the end of the previous run.\n#           * If do() takes 3 seconds, do() will be called again immediately after\n#             the end of the previous run (no double running like window.setInterval())\n#     \n#         Note that SleepTimer is often a better option than IntervalTimer because it\n#         ensures a set amount of time between runs.\n#     \n# Usage:\n#\n#     $('#somediv').timers().Timer(options).do(...)\n#     $('#somediv').timers().SleepTimer(options).do(...)\n#     $('#somediv').timers().SleepAfterTimer(options).do(...)\n#     $('#somediv').timers().IntervalTimer(options).do(...)\n#     $('#somediv').timers().IntervalAfterTimer(options).do(...)\n#\n#     Specfy options as:\n#         {\n#             # timer duration in milliseconds\n#             'millis': 1000,\n#\n#             # maximum number of timer callbacks (< 1 is infinite runs)\n#             'max_runs': 0,\n#\n#             # name of this timer - (elem + name) is unique and cancels any\n#             # previous timer with the same name on the elemnent\n#             'name': 'default',\n#         }\n#\n#     Use the promise pattern to specify the callbacks:\n#         do() is run each time the timer expires\n#         then() is run one time after max_runs is reached or the timer is cancelled\n#         fail() is run if an exception is thrown in do() methods\n#     The timer object is sole parameter to your callbacks (`this` is also available).\n#\n#     Shortcut functions:\n#         $('#somediv').timers('cancel')          # Cancels all timers on #somediv\n#         $('#somediv').timers('cancel', 'name')  # Cancels named timer on #somediv\n#         $('#somediv').timers('list')            # Returns the timer objects on #somediv\n#    \n#     Any of the following will cancel a timer:\n#       * If $('#myid').timers('cancel') is called.\n#       * If elem is removed from the document (DOM).\n#       * If another timer with the same name is placed on elem.\n#     \n#     Global options:\n#     \n#         $.fn.timers.defaults.millis = 2000\n#\n   \nDEFAULT_OPTIONS = {\n    # timer duration in milliseconds\n    'millis': 1000,\n\n    # maximum number of timer callbacks (< 1 is infinite runs)\n    'max_runs': 0,\n\n    # name of this timer (only one timer of a given name can exist\n    # on a given element at a time).\n    'name': 'default',    \n}\n\n# we don't need to be in an anonymous function because Transcrypt already places\n# everything in this file inside one - we're already in a local scope.\nS = jQuery\n\nfrom storage import get_timers\n\n############################################\n###  Main plugin entry point\n\ndef timers(options, tname):\n    '''Main plugin function'''\n    elems = this\n    \n    # shortcuts\n    if options == 'cancel':\n        for e in elems:\n            for timer in get_timers(S(e), tname):\n                timer.cancel()\n        return elems\n        \n    elif options == 'list':\n        timers = []\n        for e in elems:\n            timers.extend(get_timers(S(e), tname))\n        return timers\n        \n    # if we get here, the user is hitting the secondary namespace\n    return SecondaryNamespace(elems)\n        \n        \n# attach plugin fnction to jQuery prototype\n# only one function so not using extend()\nS.fn.timers = timers\n\n# allow end users to change the default options\nS.fn.timers.defaults = DEFAULT_OPTIONS\n\n\n\n\n\n####################################################################\n###  A secondary namespace that allows us to have multiple functions\n###  under a single name (see jQuery namespace pattern), e.g.:\n###\n###      $('#div1').timers().Timer({...})\n###      $('#div2').timers().SleepTimer({...})\n\nimport timer_once, timer_sleep, timer_interval\n\n\nclass SecondaryNamespace(object):\n    '''\n    Factory that creates timer classes.  To have a secondary namespace,\n    we have to hold the `this` variable from the primary call.  We\n    create this object when .timers() is called, which holds `elems`\n    for the secondary call (one of the methods below).\n    '''\n    def __init__(self, elems):\n        self.elems = elems\n        \n    def _create_timer(self, klass, options):\n        deferred = S.Deferred()\n        combined = update_options(options)\n        for e in self.elems:\n            klass(e, combined, deferred)\n        p = deferred.promise()\n        p.do = p.progress  # alias because \"do\" is a more appropriate name, but we still are able to take advantage of built-in functionality\n        return p\n        \n    def Timer(self, options):\n        return self._create_timer(timer_once.OnceTimer, options)\n        \n    def SleepTimer(self, options):\n        return self._create_timer(timer_sleep.SleepTimer, options)\n\n    def SleepAfterTimer(self, options):\n        return self._create_timer(timer_sleep.SleepAfterTimer, options)\n\n    def IntervalTimer(self, options):\n        return self._create_timer(timer_interval.IntervalTimer, options)\n\n    def IntervalAfterTimer(self, options):\n        return self._create_timer(timer_interval.IntervalAfterTimer, options)\n\n\n\n###############################################\n###  Utility functions\n\ndef update_options(options):\n    '''helper method that combines the defaults and options'''\n    combined = {}\n    combined.update(S.fn.timers.defaults)\n    if options is not None:\n        combined.update(options)\n    return combined\n\n\n\n"
	],
	"mappings": "AAAA;AA4OA;AAAA;AAAA;AA5GA;AAcA;AAEA;AAKA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAKA;AAGA;AAaA;AAAA;AAAA;AAGA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAOA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}