{
	"version": 3,
	"file": "src/__javascript__/timer_base.mod.js",
	"sources": [
		"src/timer_base.py"
	],
	"sourcesContent": [
		"__pragma__('alias', 'js_finally', 'finally')\nfrom storage import get_timers, set_timer, remove_timer\n\n\nclass BaseTimer(object):\n    '''The base timer class.'''\n    def __init__(self, elem, options):\n        self.elem = elem\n        self.millis = options['millis']\n        self.maxRuns = options['maxRuns']\n        self.tname = options['name']\n        \n        # timer state\n        self.timerId = None\n        self.timerStart = None  # IntervalTimer needs this to be initially None\n        self.runIndex = 0\n        self.finished = False\n        \n        # remove any existing, and place this timer on element\n        for other_timer in get_timers(self.elem, self.tname):\n            if other_timer is not self:\n                other_timer.cancel()\n        set_timer(self.elem, self.tname, self)\n        \n        # set up the observer lists\n        # this is set to None when the timer is finished\n        self.observers = {\n            'do': [],\n            'then': [],\n            'catch': [],\n        }\n        \n        # finally, start the timer\n        self._renewTimer()\n        \n        \n    def cancel(self):\n        '''Cancels the timer - triggers .then()'''\n        self._notifyObservers('then', [ self ])\n        self._finalizeTimer()\n        \n        \n    ############################################\n    ###  Private methods\n    \n    def _finalizeTimer(self):\n        '''Called when the timer is entirely finished'''\n        remove_timer(self.elem, self.tname)\n        if self.timerId:\n            window.clearTimeout(self.timerId)\n            self.timerId = None\n        self.observers = None\n            \n\n    def _renewTimer(self):\n        '''Restarts the timer, assuming we can run again'''\n        if not self._shouldRunAgain():\n            self._notifyObservers('then', [ self ])\n            self._finalizeTimer()\n        else:\n            self.timerStart = __new__(Date()).getTime()\n            self.timerId = window.setTimeout(self._onTimeout, self._nextMillis())\n        \n\n    def _nextMillis(self):\n        return self.millis  # subclasses like IntervalTimer adjust this\n\n        \n    def _onTimeout(self):\n        '''Triggered when setTimeout is done'''\n        if not self._shouldRunAgain():\n            self._notifyObservers('then', [ self ])\n            self._finalizeTimer()\n        else:\n            self.runIndex += 1\n            try:\n                self._notifyObservers('do', [ self ])\n            except Error as err:\n                if self.observers is None:\n                    raise err  # just raise normally becaues finished\n                self._notifyObservers('catch', [ self, err ])\n                self._finalizeTimer()\n                return\n            self._renewTimer()  # next run\n\n\n    def _shouldRunAgain(self):\n        # 1) in dom, 2) pending, 3) valid millis, 4) less than max runs\n        return \\\n            (self.elem is not None and (document == self.elem or document.contains(self.elem))) and \\\n            (self.observers is not None) and \\\n            (self.millis >= 0) and \\\n            (self.maxRuns <= 0 or self.runIndex < self.maxRuns)\n            \n\n        \n    #####################################################################\n    ###  Observers - I'm matching the API of A+ promises (somewhat)\n    ###  for familiarity in use, but these are observers, not promises.\n    ###  A repeating timer function doesn't really match the promise pattern.\n    \n    def do(self, onAlarm):\n        '''Registers an observer to be called each time the timer reaches zero.'''\n        return self._registerObserver('do', onAlarm)\n        \n\n    def catch(self, onError):\n        '''\n        Registers an observer to be called when exceptions occur.\n        Exceptions cancel the timer.\n        '''\n        return self._registerObserver('catch', onError)\n\n        \n    def then(self, onFinish):\n        '''\n        Registers an observer to be called when the timer is finished.\n        This could be max_timers or by cancel() being called.\n        This method is triggered only once.\n        '''\n        return self._registerObserver('then', onFinish)\n\n        \n    def _registerObserver(self, observer_key, callback):\n        if self.observers and self.observers[observer_key]:\n            self.observers[observer_key].append(callback)\n        return self  # allow chaining\n            \n\n    def _notifyObservers(self, observer_key, args):\n        if self.observers and self.observers[observer_key]:\n            for f in self.observers[observer_key]:\n                f.apply(self.elem, args)\n\n            \n\n        "
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AAOA;AAAA;AAGA;AAEA;AACA;AAAA;AAMA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAGA;AAAA;AAYA;AAEA;AAAA;AAGA;AAKA;AAAA;AAGA;AAMA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}