{
	"version": 3,
	"file": "src/__javascript__/timer_base.mod.js",
	"sources": [
		"src/timer_base.py"
	],
	"sourcesContent": [
		"from storage import get_timers, set_timer, remove_timer\nS = jQuery\n\n\nclass BaseTimer(object):\n\n    '''A timer that runs func one time after the given millis.'''\n    def __init__(self, elem, options, deferred):\n        self.elem = elem\n        self.millis = options['millis']\n        self.max_runs = options['max_runs']\n        self.tname = options['name']\n        self.deferred = deferred\n        \n        # timer state\n        self.timer_id = None\n        self.timer_start = None  # IntervalTimer needs this to be initially None\n        self.run_count = 0\n        self.cancelled = False\n        \n        # remove any existing, and place this timer on element\n        for other_timer in get_timers(S(self.elem), self.tname):\n            if other_timer is not self:\n                other_timer.cancel()\n        set_timer(S(self.elem), self.tname, self)\n        \n        # start the timer\n        self.start()\n        \n        \n    def start(self):\n        '''Starts the timer running'''\n        if not self._shouldRunAgain():\n            self._cleanup()\n            self.deferred.resolveWith(self.elem, [ self ])\n        else:\n            self.timer_start = __new__(Date()).getTime()\n            self.timer_id = self._startTimer()\n\n\n    def cancel(self):\n        '''Cancels the timer - triggers .then()'''\n        self.cancelled = True\n        self._cleanup()\n        self.deferred.resolveWith(self.elem, [ self ])\n        \n        \n    ############################################\n    ###  Private methods\n\n    def _startTimer(self):\n        '''Helper function for start().  Call window.setTimeout and return the id'''\n        console.warn('Subclass did not implement _startTimer')\n        \n    def _notifyObservers(self):\n        '''Function registered when the timer reaches zero. Triggers the callbacks.'''\n        if not self._shouldRunAgain():\n            self._cleanup()\n            self.deferred.resolveWith(self.elem, [ self ])\n        else:\n            self.run_count += 1\n            try:\n                self.deferred.notifyWith(self.elem, [ self ])\n            except Error as err:\n                self._cleanup()\n                if self.deferred.state() != 'pending':\n                    raise err  # resolve or reject already ran, so just raise normally\n                self.deferred.rejectWith(self.elem, [ self, err ])\n                return\n            self.start()\n\n    def _shouldRunAgain(self):\n        '''Returns whether the timer should run again'''\n        # 1) in dom, 2) not cancelled, 3) valid millis, 4) less than max runs, 5) deferred is still pending\n        return \\\n            (self.elem is not None and (document == self.elem or S.contains(document, self.elem))) and \\\n            (not self.cancelled) and \\\n            (self.millis >= 0) and \\\n            (self.max_runs <= 0 or self.run_count < self.max_runs) and \\\n            (self.deferred.state() == 'pending')\n            \n\n    def _cleanup(self):\n        remove_timer(S(self.elem), self.tname)\n        window.clearTimeout(self.timer_id)\n        self.timer_id = None\n\n\n            \n            \n            "
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAMA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAQA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}