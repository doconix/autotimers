{
	"version": 3,
	"file": "src/__javascript__/timer_base.mod.js",
	"sources": [
		"src/timer_base.py"
	],
	"sourcesContent": [
		"from storage import get_timers, set_timer, remove_timer\nfrom promise import TimerPromise\n\n\nclass BaseTimer(object):\n    '''The base timer class.'''\n    def __init__(self, elem, options):\n        self.elem = elem\n        self.millis = options['millis']\n        self.maxRuns = options['maxRuns']\n        self.tname = options['name']\n        \n        # timer state\n        self.timer_id = None\n        self.timer_start = None  # IntervalTimer needs this to be initially None\n        self.run_index = 0\n        self.cancelled = False\n        \n        # remove any existing, and place this timer on element\n        for other_timer in get_timers(self.elem, self.tname):\n            if other_timer is not self:\n                other_timer.cancel()\n        set_timer(self.elem, self.tname, self)\n        \n        # start the timer\n        self.promise = TimerPromise(self._renewTimer)\n        \n        \n    def cancel(self):\n        '''Cancels the timer - triggers .then()'''\n        self.cancelled = True\n        self._cleanup()\n        self.promise.resolve.apply(self.elem, [ self ])\n        \n        \n    ############################################\n    ###  Private methods\n    \n    def _renewTimer(self):\n        console.log(11)\n        if not self._shouldRunAgain():\n            console.log(22)  \n            self._cleanup()\n            self.promise.resolve.apply(self.elem, [ self ])\n        else:\n            console.log(33)\n            self.timer_start = __new__(Date()).getTime()\n            self.timer_id = window.setTimeout(self._onTimeout, self._nextMillis())\n            \n\n    def _nextMillis(self):\n        return self.millis  # subclasses like IntervalTimer adjust this\n\n        \n    def _onTimeout(self):\n        if not self._shouldRunAgain():\n            self._cleanup()\n            self.promise.resolve.apply(self.elem, [ self ])\n        else:\n            self.run_index += 1\n            try:\n                self.palarm(self.elem, [ self ])\n            except Error as err:\n                self._cleanup()\n                if not self.promise.pending:\n                    raise err  # resolve or reject already ran, so just raise normally\n                self.promise.reject.apply(self.elem, [ self, err ])\n                return\n            self._doAlarm()\n\n\n    def _shouldRunAgain(self):\n        # 1) in dom, 2) not cancelled, 3) valid millis, 4) less than max runs, 5) deferred is still pending\n        return \\\n            (self.elem is not None and (document == self.elem or document.contains(self.elem))) and \\\n            (not self.cancelled) and \\\n            (self.millis >= 0) and \\\n            (self.maxRuns <= 0 or self.run_index < self.maxRuns) and \\\n            (self.deferred.state() == 'pending')\n            \n\n    def _cleanup(self):\n        remove_timer(self.elem, self.tname)\n        window.clearTimeout(self.timer_id)\n        self.timer_id = None\n            "
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAOA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}